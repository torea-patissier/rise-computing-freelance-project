{"ast":null,"code":"import { downloadSvgImage, loadImage, replaceImageColor } from \"./Utils\";\nexport class ImageDrawer {\n  constructor() {\n    this._images = [];\n  }\n\n  addImage(container, image) {\n    const containerImages = this.getImages(container);\n    containerImages === null || containerImages === void 0 ? void 0 : containerImages.images.push(image);\n  }\n\n  destroy() {\n    this._images = [];\n  }\n\n  draw(context, particle, radius, opacity) {\n    var _a;\n\n    const image = particle.image,\n          element = image === null || image === void 0 ? void 0 : image.element;\n\n    if (!element) {\n      return;\n    }\n\n    const ratio = (_a = image === null || image === void 0 ? void 0 : image.ratio) !== null && _a !== void 0 ? _a : 1,\n          pos = {\n      x: -radius,\n      y: -radius\n    };\n    context.globalAlpha = opacity;\n    context.drawImage(element, pos.x, pos.y, radius * 2, radius * 2 / ratio);\n    context.globalAlpha = 1;\n  }\n\n  getImages(container) {\n    const containerImages = this._images.find(t => t.id === container.id);\n\n    if (!containerImages) {\n      this._images.push({\n        id: container.id,\n        images: []\n      });\n\n      return this.getImages(container);\n    } else {\n      return containerImages;\n    }\n  }\n\n  getSidesCount() {\n    return 12;\n  }\n\n  loadShape(particle) {\n    if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n      return;\n    }\n\n    const container = particle.container,\n          images = this.getImages(container).images,\n          imageData = particle.shapeData,\n          image = images.find(t => t.source === imageData.src);\n\n    if (!image) {\n      this.loadImageShape(container, imageData).then(() => {\n        this.loadShape(particle);\n      });\n    }\n  }\n\n  particleInit(container, particle) {\n    var _a;\n\n    if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n      return;\n    }\n\n    const images = this.getImages(container).images,\n          imageData = particle.shapeData,\n          color = particle.getFillColor(),\n          replaceColor = (_a = imageData.replaceColor) !== null && _a !== void 0 ? _a : imageData.replace_color,\n          image = images.find(t => t.source === imageData.src);\n\n    if (!image) {\n      return;\n    }\n\n    if (image.loading) {\n      setTimeout(() => {\n        this.particleInit(container, particle);\n      });\n      return;\n    }\n\n    (async () => {\n      var _a, _b;\n\n      let imageRes;\n\n      if (image.svgData && color) {\n        imageRes = await replaceImageColor(image, imageData, color, particle);\n      } else {\n        imageRes = {\n          color,\n          data: image,\n          element: image.element,\n          loaded: true,\n          ratio: imageData.width / imageData.height,\n          replaceColor: replaceColor,\n          source: imageData.src\n        };\n      }\n\n      if (!imageRes.ratio) {\n        imageRes.ratio = 1;\n      }\n\n      const fill = (_a = imageData.fill) !== null && _a !== void 0 ? _a : particle.fill,\n            close = (_b = imageData.close) !== null && _b !== void 0 ? _b : particle.close,\n            imageShape = {\n        image: imageRes,\n        fill,\n        close\n      };\n      particle.image = imageShape.image;\n      particle.fill = imageShape.fill;\n      particle.close = imageShape.close;\n    })();\n  }\n\n  async loadImageShape(container, imageShape) {\n    var _a;\n\n    const source = imageShape.src;\n\n    if (!source) {\n      throw new Error(\"Error tsParticles - No image.src\");\n    }\n\n    try {\n      const image = {\n        source: source,\n        type: source.substring(source.length - 3),\n        error: false,\n        loading: true\n      };\n      this.addImage(container, image);\n      const imageFunc = ((_a = imageShape.replaceColor) !== null && _a !== void 0 ? _a : imageShape.replace_color) ? downloadSvgImage : loadImage;\n      await imageFunc(image);\n    } catch (_b) {\n      throw new Error(`tsParticles error - ${imageShape.src} not found`);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/torea/Desktop/freelanceProject2/rise-consulting/node_modules/tsparticles-shape-image/esm/ImageDrawer.js"],"names":["downloadSvgImage","loadImage","replaceImageColor","ImageDrawer","constructor","_images","addImage","container","image","containerImages","getImages","images","push","destroy","draw","context","particle","radius","opacity","_a","element","ratio","pos","x","y","globalAlpha","drawImage","find","t","id","getSidesCount","loadShape","shape","imageData","shapeData","source","src","loadImageShape","then","particleInit","color","getFillColor","replaceColor","replace_color","loading","setTimeout","_b","imageRes","svgData","data","loaded","width","height","fill","close","imageShape","Error","type","substring","length","error","imageFunc"],"mappings":"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","sourcesContent":["import { downloadSvgImage, loadImage, replaceImageColor } from \"./Utils\";\nexport class ImageDrawer {\n    constructor() {\n        this._images = [];\n    }\n    addImage(container, image) {\n        const containerImages = this.getImages(container);\n        containerImages === null || containerImages === void 0 ? void 0 : containerImages.images.push(image);\n    }\n    destroy() {\n        this._images = [];\n    }\n    draw(context, particle, radius, opacity) {\n        var _a;\n        const image = particle.image, element = image === null || image === void 0 ? void 0 : image.element;\n        if (!element) {\n            return;\n        }\n        const ratio = (_a = image === null || image === void 0 ? void 0 : image.ratio) !== null && _a !== void 0 ? _a : 1, pos = {\n            x: -radius,\n            y: -radius,\n        };\n        context.globalAlpha = opacity;\n        context.drawImage(element, pos.x, pos.y, radius * 2, (radius * 2) / ratio);\n        context.globalAlpha = 1;\n    }\n    getImages(container) {\n        const containerImages = this._images.find((t) => t.id === container.id);\n        if (!containerImages) {\n            this._images.push({\n                id: container.id,\n                images: [],\n            });\n            return this.getImages(container);\n        }\n        else {\n            return containerImages;\n        }\n    }\n    getSidesCount() {\n        return 12;\n    }\n    loadShape(particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        const container = particle.container, images = this.getImages(container).images, imageData = particle.shapeData, image = images.find((t) => t.source === imageData.src);\n        if (!image) {\n            this.loadImageShape(container, imageData).then(() => {\n                this.loadShape(particle);\n            });\n        }\n    }\n    particleInit(container, particle) {\n        var _a;\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        const images = this.getImages(container).images, imageData = particle.shapeData, color = particle.getFillColor(), replaceColor = (_a = imageData.replaceColor) !== null && _a !== void 0 ? _a : imageData.replace_color, image = images.find((t) => t.source === imageData.src);\n        if (!image) {\n            return;\n        }\n        if (image.loading) {\n            setTimeout(() => {\n                this.particleInit(container, particle);\n            });\n            return;\n        }\n        (async () => {\n            var _a, _b;\n            let imageRes;\n            if (image.svgData && color) {\n                imageRes = await replaceImageColor(image, imageData, color, particle);\n            }\n            else {\n                imageRes = {\n                    color,\n                    data: image,\n                    element: image.element,\n                    loaded: true,\n                    ratio: imageData.width / imageData.height,\n                    replaceColor: replaceColor,\n                    source: imageData.src,\n                };\n            }\n            if (!imageRes.ratio) {\n                imageRes.ratio = 1;\n            }\n            const fill = (_a = imageData.fill) !== null && _a !== void 0 ? _a : particle.fill, close = (_b = imageData.close) !== null && _b !== void 0 ? _b : particle.close, imageShape = {\n                image: imageRes,\n                fill,\n                close,\n            };\n            particle.image = imageShape.image;\n            particle.fill = imageShape.fill;\n            particle.close = imageShape.close;\n        })();\n    }\n    async loadImageShape(container, imageShape) {\n        var _a;\n        const source = imageShape.src;\n        if (!source) {\n            throw new Error(\"Error tsParticles - No image.src\");\n        }\n        try {\n            const image = {\n                source: source,\n                type: source.substring(source.length - 3),\n                error: false,\n                loading: true,\n            };\n            this.addImage(container, image);\n            const imageFunc = ((_a = imageShape.replaceColor) !== null && _a !== void 0 ? _a : imageShape.replace_color) ? downloadSvgImage : loadImage;\n            await imageFunc(image);\n        }\n        catch (_b) {\n            throw new Error(`tsParticles error - ${imageShape.src} not found`);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}